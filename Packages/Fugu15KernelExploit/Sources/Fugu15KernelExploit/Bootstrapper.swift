import CBindings;
import PatchfinderUtils;

public enum BootstrapError: Error {
	case custom(_: String)
}


class Bootstrapper {
	static func remountPrebootPartition(writable: Bool) -> Int32? {
		if writable {
			return execCmd(args: ["/sbin/mount", "-u", "-w", "/private/preboot"])
		} else {
			return execCmd(args: ["/sbin/mount", "-u", "/private/preboot"])
		}
	}
	
	static func untar(tarPath: String, target: String) -> Int32? {
		let tarBinary = Bundle.main.bundlePath + "/tar"
		try? FileManager.default.setAttributes([.posixPermissions: 0o755], ofItemAtPath: tarBinary)
		return execCmd(args: [tarBinary, "-xpkf", tarPath, "-C", target]);
	}

	static func getBootManifestHash() -> String {
		let registryEntry = IORegistryEntryFromPath(kIOMainPortDefault, "IODeviceTree:/chosen")
		let bootManifestHash = IORegistryEntryCreateCFProperty(registryEntry, "boot-manifest-hash" as CFString, kCFAllocatorDefault, 0).takeRetainedValue() as! Data
		return bootManifestHash.map { String(format: "%02X", $0) }.joined()
	}

	static func generateFakeRootPath() -> String {
		let letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
		var result = ""
		for _ in 0..<6 {
			let randomIndex = Int(arc4random_uniform(UInt32(letters.count)))
			let randomCharacter = letters[letters.index(letters.startIndex, offsetBy: randomIndex)]
			result += String(randomCharacter)
		}
		return "/private/preboot/" + getBootManifestHash() + "/jb-" + result
	}

	static func locateExistingFakeRoot() -> String? {
		let ppURL = URL(fileURLWithPath: "/private/preboot/" + getBootManifestHash())
		guard let candidateURLs = try? FileManager.default.contentsOfDirectory(at: ppURL , includingPropertiesForKeys: nil, options: []) else { return nil }
		for candidateURL in candidateURLs {
			if candidateURL.lastPathComponent.hasPrefix("jb-") {
				return candidateURL.path
			}
		}
		return nil
	}

	static func wipeXinaSymlink(atPath path: String) throws {
		let fileManager = FileManager.default
		let attributes = try fileManager.attributesOfItem(atPath: path)
		if let fileType = attributes[.type] as? FileAttributeType, fileType == .typeSymbolicLink {
			try fileManager.removeItem(atPath: path)
			Logger.print("[Xina Cleanup] Deleted symlink at \(path)")
		} else {
			Logger.print("[Xina Cleanup] \(path) is not a symlink")
		}
	}

	static func extractBootstrap() throws {
		let jbPath = "/var/jb"

		if remountPrebootPartition(writable: true) != 0 {
			throw BootstrapError.custom("Failed to remount /private/preboot partition as writable")
		}

		// Remove existing /var/jb symlink if it exists (will be recreated later)
		if FileManager.default.fileExists(atPath: jbPath) {
			try FileManager.default.removeItem(atPath: jbPath)
		}

		// If xina was used before, clean the mess it creates in /var
		// Xina will recreate them on the next jb through it so there is no loss here
		let xinaInstalled = FileManager.default.fileExists(atPath: "/var/LIY")
		if xinaInstalled {
			let xinaVarSymlinks = [
				"alternatives",
				"ap",
				"apt",
				"bin",
				"bzip2",
				"cache",
				"dpkg",
				"etc",
				"gzip",
				"lib",
				"Lib",
				"libexec",
				"Library",
				"LIY",
				"Liy",
				"local",
				"newuser",
				"profile",
				"sbin",
				"suid_profile",
				"sh",
				"sy",
				"share",
				"ssh",
				"sudo_logsrvd.conf",
				"suid_profile",
				"sy",
				"usr",
				"zlogin",
				"zlogout",
				"zprofile",
				"zshenv",
				"zshrc"
			]

			for xinaVarSymlink in xinaVarSymlinks {
				let symlinkPathToWipe = "/var/" + xinaVarSymlink
				try wipeXinaSymlink(atPath: symlinkPathToWipe)
			}
		}
		
		// Ensure fake root directory inside /private/preboot exists
		var fakeRootPath = locateExistingFakeRoot()
		if fakeRootPath == nil {
			fakeRootPath = generateFakeRootPath()
			try FileManager.default.createDirectory(atPath: fakeRootPath!, withIntermediateDirectories: true)
		}
		
		// Extract Procursus Bootstrap if neccessary
		var bootstrapNeedsExtract = false
		let procursusPath = fakeRootPath! + "/procursus"
		let installedPath = procursusPath + "/.installed_fugu15max"
		let rePath = "/var/mobile/.re"
		if FileManager.default.fileExists(atPath: procursusPath) {
			if FileManager.default.fileExists(atPath: rePath) {
				Logger.print("re install fugu max")
				try FileManager.default.removeItem(atPath: rePath)
				try FileManager.default.removeItem(atPath: installedPath)
			}
			if !FileManager.default.fileExists(atPath: installedPath) {
				Logger.print("Wiping existing bootstrap because installed file not found")
				try FileManager.default.removeItem(atPath: procursusPath)
			}
		}
		if !FileManager.default.fileExists(atPath: procursusPath) {
			try FileManager.default.createDirectory(atPath: procursusPath, withIntermediateDirectories: true)
			bootstrapNeedsExtract = true
		}
		
		// Update basebin (should be done every rejailbreak)
		let basebinTarPath = Bundle.main.bundlePath + "/basebin.tar"
		let basebinPath = procursusPath + "/basebin"
		if FileManager.default.fileExists(atPath: basebinPath) {
			try FileManager.default.removeItem(atPath: basebinPath)
		}
		let untarRet = untar(tarPath: basebinTarPath, target: procursusPath)
		if untarRet != 0 {
			throw BootstrapError.custom(String(format:"Failed to untar Basebin: \(String(describing: untarRet))"))
		}

		// Create /var/jb symlink
		try FileManager.default.createSymbolicLink(atPath: jbPath, withDestinationPath: procursusPath)

		// Extract Procursus if needed
		if bootstrapNeedsExtract {
			let procursusTarPath = Bundle.main.bundlePath + "/bootstrap.tar"
			let untarRet = untar(tarPath: procursusTarPath, target: "/")
			if untarRet != 0 {
				throw BootstrapError.custom(String(format:"Failed to untar Procursus: \(String(describing: untarRet))"))
			}
			try "".write(toFile: installedPath, atomically: true, encoding: String.Encoding.utf8)
		}

		// Write boot info from cache to disk
		let bootInfoURL = URL(fileURLWithPath: "/var/jb/basebin/boot_info.plist")
		try? cachedBootInfo.write(to: bootInfoURL)
	}

	static func needsFinalize() -> Bool {
		return FileManager.default.fileExists(atPath: "/var/jb/prep_bootstrap.sh")
	}

	static func finalizeBootstrap() throws {
		let prepRet = execCmd(args: ["/var/jb/bin/sh", "/var/jb/prep_bootstrap.sh"])
		if prepRet != 0 {
			throw BootstrapError.custom(String(format:"Failed to finalize bootstrap, prep_bootstrap.sh failed with error code: \(prepRet)"))
		}

		let zebraRet = execCmd(args: ["/var/jb/usr/bin/dpkg", "-i", Bundle.main.bundlePath + "/zebra.deb"])
		if zebraRet != 0 {
			throw BootstrapError.custom(String(format:"Failed to finalize bootstrap, installing Zebra failed with error code: \(zebraRet)"))
		}

		let sileoRet = execCmd(args: ["/var/jb/usr/bin/dpkg", "-i", Bundle.main.bundlePath + "/sileo.deb"])
		if sileoRet != 0 {
			throw BootstrapError.custom(String(format:"Failed to finalize bootstrap, installing Sileo failed with error code: \(sileoRet)"))
		}

		execCmd(args: ["/var/jb/usr/bin/uicache", "-u", "/var/jb/Applications/Zebra.app"])
		execCmd(args: ["/var/jb/usr/bin/uicache", "-u", "/var/jb/Applications/Sileo-Nightly.app"])

		// TEMP: Set root pw to "alpine", should be removed later when the main app has the ability to set it
		try FileManager.default.removeItem(atPath: "/var/jb/etc/master.passwd")
		try FileManager.default.copyItem(atPath: Bundle.main.bundlePath + "/master.rootalpine.passwd", toPath: "/var/jb/etc/master.passwd")
		execCmd(args: ["/var/jb/usr/sbin/pwd_mkdb", "-d", "/var/jb/etc", "/var/jb/etc/master.passwd"])
	}

	static func doHide() {
		// Remove existing /var/jb symlink if it exists (will be recreated on next jb)
		// This is the only thing that apps could detect when the device is not actually jailbroken
		// Except for apps that check for random preferences and shit on /var (something no app should ever do because of way to many false positives, feel free to send this comment to your manager)
		
		let jbPath = "/var/jb"

		if remountPrebootPartition(writable: true) != 0 {
			Logger.print("Failed to remount /private/preboot partition as writable")
			return
		}
		
		do {
			if FileManager.default.fileExists(atPath: jbPath) {
				try FileManager.default.removeItem(atPath: jbPath)
			}
		} catch let error as NSError {
			Logger.print("Failed to delete /var/jb symlink: \(error)")
			return
		}
		
		if remountPrebootPartition(writable: false) != 0 {
			Logger.print("Failed to remount /private/preboot partition as non-writable")
			return
		}
	}

	static func doUninstall() {
		let jbPath = "/var/jb"
		
		if remountPrebootPartition(writable: true) != 0 {
			Logger.print("Failed to remount /private/preboot partition as writable")
			return
		}
		
		// Delete /var/jb symlink
		do {
			if FileManager.default.fileExists(atPath: jbPath) {
				try FileManager.default.removeItem(atPath: jbPath)
			}
		} catch let error as NSError {
			Logger.print("Failed to delete /var/jb symlink: \(error)")
			return
		}
		
		// Delete fake root
		let fakeRootPath = locateExistingFakeRoot()
		if fakeRootPath != nil {
			do {
				try FileManager.default.removeItem(atPath: fakeRootPath!)
			}
			catch let error as NSError {
				Logger.print("Failed to delete fake root: \(error)")
				return
			}
		}
		
		if remountPrebootPartition(writable: false) != 0 {
			Logger.print("Failed to remount /private/preboot partition as non-writable")
			return
		}
	}

	static func isBootstrapped() -> Bool {
		return locateExistingFakeRoot() != nil
	}
}
